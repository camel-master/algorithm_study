"""
BOJ 1931 회의실 배정
https://www.acmicpc.net/problem/1931

회의 A, B, C가 있다고 할 때
사용 시간은 다음과 같이 여러 패턴이 있을 수 있다.
A ----
B     ----
C         ----
A --------
B     --------
C      ----------

1. 회의 시간 데이터를 가장 짧은 회의 중 가장 먼저 시작하는 회의 순으로 정렬한다.

2. 시간표는 0 ~ 2^31 사이로 구성된다. 시간표 안의 모든 시각을 0으로 초기화 한다.

3. 정렬된 순서대로 데이터를 꺼내서 해당 구간에 진행되는 회의가 없는경우 그 구간 만큼
   시간을 1로 변경하고 카운팅한다.

시간복잡도
데이터 정렬은 O(N log N) = 1660964
시간표 안에 시간이 겹치는지 확인하는 것은 O(N * T) 최대 2^31 - 1회 = 2147483647
전체 시간표에 대해 꽉차게 조회하게 되는 경우 시간제한에 간당간당 걸릴 수도 있겠다.

공간복잡도.
시간표 데이터를 저장하는 경우 2147483647 * 4 = 2GB를 사용하게 되어 메모리 초과이다.

따라서 위 방법은 사용할 수 없다.

알고리즘을 다음과 같이 재작성했다.

1. 최초 회의 종료 시각은 0이다.

2. 회의 시간 데이터를 가장 짧은 회의 중 가장 먼저 시작하는 회의 순으로 정렬한다.

3. 앞의 회의와 겹치지 않는 회의일 경우 선택하고 회의 종료 시각을 업데이트 한다.

시간복잡도.
데이터 정렬에 O(N log N) 이므로 최대 1,660,964번 연산
회의 데이터 접근에는 O(N)이다.
따라서 시간제한 2를 통과할 수 있으니 사용할 수 있는 알고리즘이다.

공간복잡도
회의 데이터만 가지고 있으면 되므로, 최대로 100,000개의 회의가 있다고 할 때 시작시각, 종료시각을
가지므로 200,000 * 4 = 0.7mb로 해결할 수 있으므로 공간 복잡면에서도 사용할 수 있는 알고리즘이다.

위의 알고리즘은 틀린 결과를 보여준다.

1. 회의시간 데이터 정렬하되 primary 정렬 기준은 종료시각으로 하고 secondary 정렬 기준을 시작시각으로 한다.
   가장 빨리 끝나는 회의 중 가장 먼저 시작되는 회의를 고르도록 하기 위해서이다.

2. 정렬된 회의 데이터를 순회하면서 time conflict가 발생하지 않는 건들에 대해서만 카운팅한다.

시간, 공간 복잡도는 위의 잘못된 알고리즘과 동일하다. 사용할 수 있는 알고리즘이다.
"""
import sys
f_input = sys.stdin.readline

N = int(f_input())
meet_info = list()
for _ in range(N):
    meet_info.append(tuple(map(int, f_input().rstrip().split())))

meet_info.sort(key=lambda x: (x[1], x[0]))

curr_e_time = 0
meet_cnt = 0
for mi in meet_info:
    if mi[0] >= curr_e_time:
        meet_cnt += 1
        curr_e_time = mi[1]

print(meet_cnt)
