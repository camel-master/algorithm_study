"""
BOJ 1052 물병

N = 1리터씩 채워져 있는 물병 개수
K = 물을 재분배 하여 만들어야 하는 물이 채워진 물병 개수
물의 재분배는 다음과 같은 조건으로 진행
    1. 같은 양의 병 두개를 선택
    2. 고른 물병 가운데 하나를 취해 다른 물병에 모두 담는다.
물병을 합칠 때 합치지 못하고 남은 물병이 하나 남은 경우. 즉, 동일 수위로 채워진 물병이
홀수 인 경우 1리터씩 채워진 물병을 추가로 구입하여 물병을 합칠 수 있다.

물의 양 = 1
구매물병 = 0
while N <= K
    초기 물병은 1리터씩 채워져 있으므로 물병 개수가 홀수인지 짝수인지 확인한다.
    if N = 짝수 then
        # 물병을 구입하지 않는다.
        N = N // 2가 된다.
    else then
        구매물병을 = 구매물병 + 물의 양
        N = N // 2 + 1이 된다.

    # 물의 양은 두 배씩 증가하므로...
    물의 양 = 물의 양 * 2

"""
# def get_bottle_count(N, K):
#     wl = 1  # water level
#     ab_cnt = 0  # additional bottle count
#     while True:
#         if N <= K:
#             break
#         if N % 2 == 1:
#             ab_cnt += wl
#             N = N // 2 + 1
#         else:
#             N //= 2
#         wl *= 2
#
#     return ab_cnt
#
#
# N, K = map(int, input().split())
# print(get_bottle_count(N, K))
"""
7 3 입력 시 추가로 필요한 물병 없이 3개로 처리가 가능해야 하지만 위의 코드는 그 부분을 처리하지 못했음.

물병 물의 높이는 1, 2, 4, 8, 16, ... 2^n
1 <= N < 100,000,000
따라서 물병의 높이는 무한하지만 N에 의해 
    bottles  water_level count
100,000,000            1    0
 50,000,000            2    0
 25,000,000            4    0
 12,500,000            8    0
  6,250,000           16    0
  3,125,000           32    0
  1,562,500           64    0
    781,250          128    0
    390,625          256    1
    195,312          513    0
     97,656         1024    0
     48,828         2048    0
     24,414         4096    0
     12,207         8192    1
      6,103        16384    1
      3,051        32768    1
      1,525        65536    1
        762       131072    0
        381       262144    1
        190       524288    0
         95      1048576    1
         47      2097152    1
         23      4194304    1
         11      8388608    1
          5     16777216    1
          2     33554432    0
          1     67108864    1
물병에 들어 있는 물의 높이 범위는 1 ~ 2^27이 된다.
"""


# def find_min_WL(wl):
#     for i in range(28):
#         if wl[2 ** i] > 0:
#             return 2 ** i
#     return -1
#
#
# N, K = map(int, input().split())
# WL = dict()
# for i in range(100):
#     WL[2 ** i] = 0
# # 우선 주어진 물병을 가지고 최대한 합쳐 최소 수량을 만든다.
# curr_WL = 1
# while N > 0:
#     if N % 2 == 1:
#         WL[curr_WL] = 1
#     curr_WL *= 2
#     N = N // 2
#
# buy_amount = 0
# # 가진 물병을 최소 수량으로 만든 것이 K 이하이면 0을 출력
# if sum(WL.values()) <= K:
#     print(0)
# else:
#     # 최소 높이의 물병 부터 찍을 맞춰서 올려준다. 최소 높이 물병의 나머지는 이제 0이 된다.
#     # 올려주면서 최소 높이 물병만큼 추가 물병을 구매해야하므로 구매 물병 수량에 최소 높이 물병의 물높이를 더해준다.
#     # 올림 받은 물높이 병이 이미 하나 있는 경우 올림 받은 병이 있으므로 올림 받은 물높이의 물병은
#     # 0이되고 다시 다음 높이의 물병으로 올림이 발생된다.
#     # 올림 받은 물높이의 병 갯수가 0개인 경우 올림 받은 물높이의 병을 1로 만들고 끝난다.
#     # 물이 찬 병의 수 <= N이 될 때까지 반복한다.
#     min_WL = find_min_WL(WL)
#     while sum(WL.values()) > K:
#         if WL[min_WL] == 1:
#             buy_amount += min_WL
#         WL[min_WL] = 0
#         min_WL *= 2
#         WL[min_WL] += 1
#
#     print(buy_amount)

N, K = map(int, input().split())
res = 0

# 물병을 두 개씩 병합하여 하나로 만들고 있으므로
# N을 10이라 하면 1L 용량의 병이 10개 이다. 이 것을 병합하면
# 2L 용량의 병 5개를 만들 수 있고 남은 1L 병은 0개이다. 이를 다시 병합하면
# 4L 용량의 병 2개를 만들 수 있고 남은 2L 병은 1개이다. 이를 다시 병합하면
# 8L 용량의 병 1개를 만들 수 있고 남은 4L 병은 0개이다. 더 이상 병합할 수 없는 상태가 되었다.
# 8L ~ 1L까지 순서대로 병의 개수를 나열하면 1, 0, 1, 0 이 된다. 따라서 물이 들어있는 병은 두개이다.
# 이는 N을 2진수로 표현한 0b1010과 같다.
# 따라서 이진수 각 자리들 중 1인 것을을 카운팅하면 N개의 물병만으로 만들 수 있는 최소 물이 든 병의 수량을 알 수 있다.
# 이것을 current_min_count 라고 했을 떄, current_min_count > K이면 물이 든 물병의 수를 더 줄여야 한다.
# 이진수를 구성하는 가장 낮은 자리의 1에 해당하는 수량의 1L 물병을 더해주면서 물이 찬 물병 개수를 줄여간다.
# 즉, 위의 예에서 0b1010에서 2^1에 해당하는 것이 가장 낮은 자리의 1이므로 2^1만큼 N에 더해준다.
# N = 12가 되었고 이를 이진수로 나타내면 0b1100이다. 이제 가장 낮은 자리의 1은 2^2이므로 그만큼 N에 더해준다.
# N = 16이 되었고 이를 이진수로 나타내면 0b10000이다. 모든 자리 중 1인 요소는 하나 뿐이므로
# 1L 물병 10개에 2^1 + 2^2 만큼의 1L 물병을 더하여 1개의 물병에 다 담을 수 있게 된다.
while bin(N).count('1') > K:
    # 2^(1이 등장하는 가장 낮은 자리수) = 추가 구매된 물병의 수
    bb = 2 ** (bin(N)[::-1].index('1'))   # bottles that have buy
    res += bb
    N += bb
print(res)
