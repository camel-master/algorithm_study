"""
BOJ 3067 Coins
https://www.acmicpc.net/problem/3067

동전 종류: 2원, 3원

15원을 만들 수 있는 방법의 수를 세어보자.

index는 만들 금액이고 그 값이 만들 수있는 경우의 수인 dp table을 하나 생성한다.
먼저 0원을 만드는 방법은 아무 동전도 사용하지 않는 것이므로 0번 인덱스는 1로 나머지 인덱스는
모두 0으로 초기화 한다.
price 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
      1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0

먼저 2원 동전으로 각 가액을 만들 수 있는 경우의 수를 확인한다.
2원 이하의 가액은 2원 동전으로 만들 수 없으므로 2원 부터 만들 수 있는 경우의 수를 확인하도록 한다.
2원은 0원에서 2원을 더했을 때 2원이 되므로 인덱스 2의 값을 1로 변경한다.
다시 말해 현재 금액을 만들기 위해서는 현재 확인하고 있는 동전가액을 뺀 만큼의 경우의 수에 현재 금액을 만들 수 있는
경우의 수를 더한 것이 현재 시점의 현재 확인하고 있는 동전까지의 최대 조합 경우의 수가 된다.
price  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
2      1  0  1  0  1  0  1  0  1  0  1  0  1  0  1  0

2원 동전으로 각 가액을 만들 수 있는 경우의 수를 price에 기록해 놓은 상태에서
이제 3원 동전으로 만들 수 있는 경우의 수를 확인해보자. 당연히 3원 동전으로 3원 이하는 만들 수 없으므로
3원 부터 시작한다. 3원을 만들 수 있는 경우의 수 = 3원 - 3원의 경우의 수에 3원을 만들 수 있는 경우의 수 이므로
pric[0] + price[3] = 1 + 0 = 1 이된다.
price  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
3      1  0  1  1  1  0  1  0  1  0  1  0  1  0  1  0

나머지 4원 이후로도 동일하게 채워보자.
price  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
3      1  0  1  1  1  1  2  1  2  2  2  2  3  2  3  3

이로써 2원과 3원의 조합으로 15원을 만들 수 있는 방법의 수는 세 가지 임을 알 수 있다.

2, 2, 2, 3, 3, 3
2, 2, 2, 2, 2, 2, 3
3, 3, 3, 3, 3
"""
T = int(input())
res = list()
for _ in range(T):
    N = int(input())
    coins = list(map(int, input().split()))
    price = int(input())

    dp = [0] * (price + 1)
    dp[0] = 1
    for coin in coins:
        for c_price in range(coin, price + 1):
            dp[c_price] += dp[c_price - coin]

    res.append(dp[price])

for r in res:
    print(r)
