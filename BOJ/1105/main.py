"""
BOJ 1105 팔
https://https://www.acmicpc.net/problem/1105

L ~ R 사이가 최대로 넓어지는 경우는 1 ~ 20억이다.
선형탐색을 통해 문제에 접근할 시 시간 제한 2초를 만족할 수 없다.

1 ~ 9 사이의 8이 들어간 수는 8이다.
10 ~ 99 사이의 8이 들어간 수는
    18, 28, 38, 48, 58, 68, 78, 88, 98이다.
100 ~ 999 사이의 8이 들어간 수는
    108, 118, 128, 138, 148, 158, 168, 178, 188, 198,
    208, 218, 228, 238, 248, 258, 268, 278, 288, 298,
    308, 318, 328, 338, 348, 358, 368, 378, 388, 398,
    408, 218, 228, 238, 248, 258, 268, 278, 288, 298,
    508, 218, 228, 238, 248, 258, 268, 278, 288, 298,
    608, 218, 228, 238, 248, 258, 268, 278, 288, 298,
    708, 218, 228, 238, 248, 258, 268, 278, 288, 298,
    808, 818, 828, 838, 848, 858, 868, 878, 888, 898,
    908, 218, 228, 238, 248, 258, 268, 278, 288, 998,

가장 낮은 숫자가 얼마인지에 따라 8의 최저 개수가 달라지게 된다.
1 ~ 2000000000 사이의 가장 8이 적은 수는 0개이다.
80 ~ 2000000000 사이의 가장 8이 적은 수는 0개이다.

80 ~ 89 사이의 최소 8개수 = 1
88 ~ 88 사이의 최소 8개수 = 2

800 ~ 899 사이의 최소 8개수 = 1
880 ~ 889 사이의 최소 8개수 = 2
888 ~ 888 사이의 최소 8개수 = 3

8000 ~ 8999 사이의 최소 8개수 = 1
8800 ~ 8899 사이의 최소 8개수 = 2
8880 ~ 8889 사이의 최소 8개수 = 3
8888 ~ 8888 사이의 최소 8개수 = 4

즉, L과 R의 각 자리수별로 앞의 자리로부터 비교하여 가장 길게 연속된 '8'개수가 최소 8의 개수가 되겠다.
L과 R을 문자열로 만들고 길이를 맞춰준다.
예를 들어
L = 10, R = 200이면
L = '010', R = '200'이 되도록 한다.

L = 820, R = 880이면
L='820', R = '880'이므로
0번 인덱스 부터 순차적으로 확인하면

index    0 1 2
L value  8 2 0
R value  8 8 0
로 시작 인덱스로 부터 연속되게 8인 경우가 하나 뿐이므로 답은 1이 된다.

추가 테스트 케이스 1
8080 8180

추가 테스트 케이스 2
808 808
"""
L, R = map(str, input().split())
# L,R 문자열 길이가 다른 경우 맞추주기
if len(L) < len(R):
    L = L.zfill(len(R))

eight_cnt = 0
for l_ch, r_ch in zip(L, R):
    if l_ch == r_ch:
        if l_ch == '8':
            eight_cnt += 1
            is_pre_eight = True
    else:
        break

print(eight_cnt)
