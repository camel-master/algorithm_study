"""
BOJ 1992 쿼드트리
https://www.acmicpc.net/problem/1992

N = 2의 제곱 수 (1 <= N <= 64)

주어진 영상이 0으로만 되어있으면 압축결과 = "0"
주어진 영상이 1로만 되어있으면 압축결과 = "1"
주어진 영상에 0과 1이 혼재하면 좌상, 우상, 좌하, 우하 로 나눠서 압축을 진행한다.

압축할 데이터가 다음과 같을 때

    0 1 2 3 4 5 6 7

0   1 1 1 1 0 0 0 0
1   1 1 1 1 0 0 0 0
2   0 0 0 1 1 1 0 0
3   0 0 0 1 1 1 0 0
4   1 1 1 1 0 0 0 0
5   1 1 1 1 0 0 0 0
6   1 1 1 1 0 0 1 1
7   1 1 1 1 0 0 1 1

전체를 놓고 보면 0과 1이 혼재하므로 여는 괄호를 넣고 다음 4개의 범위로 나눠서 다시 압축을 진행한다.
0 <= r <= 3, 0 <= c <= 3
    위의 범위 안에는 0과 1이 혼재하므로 여는 괄호를 넣고 다시 4개의 범위로 나눠서 압축을 진행한다.
        0 <= r <= 1, 0 <= c <= 1
            범위 안에 모든 수가 1이므로 "1"로 압축한다.
        0 <= r <= 1, 2 <= c <= 3
            범위 안에 모든 수가 1이므로 "1"로 압축한다.
        2 <= r <= 3, 0 <= c <= 1
            범위 안에 모든 수가 0이므로 "0"으로 압축한다.
        2 <= r <= 3, 2 <= c <= 3
            범위 안에 0과 1이 혼재하므로 여는 괄호를 넣고 다시 4개의 범위로 나눠서 압축을 진행한다.
                2 <= r <= 2, 2 <= c <= 2
                    범위 안에 모든 수가 0이므로 "0"으로 압축한다.
                2 <= r <= 2, 3 <= c <= 3
                    범위 안에 모든 수가 0이므로 "1"로 압축한다.
                3 <= r <= 3, 2 <= c <= 2
                    범위 안에 모든 수가 0이므로 "0"으로 압축한다.
                3 <= r <= 3, 3 <= c <= 3
                    범위 안에 모든 수가 0이므로 "1"로 압축한다.
            압축을 진행할 데이터가 더 이상 없으므로 닫히는 괄호를 넣는다.
    압축을 진행할 데이터가 더이상 없으므로 닫히는 괄호를 넣는다.
0 <= r <= 3, 4 <= c <= 7
    위의 범위 안에는 0과 1이 혼재하므로 여는 괄호를 넣고 다시 4개의 범위로 나눠서 압축을 진행한다.
        0 <= r <= 1, 4 <= c <= 5
            범위 안에 0 밖에 없으므로 "0"으로 압축한다.
        0 <= r <= 1, 6 <= c <= 7
            범위 안에 0 밖에 없으므로 "0"으로 압축한다.
        2 <= r <= 3, 4 <= c <= 5
            범위 안에 1 밖에 없으므로 "1"으로 압축한다.
        2 <= r <= 3, 6 <= c <= 7
            범위 안에 0 밖에 없으므로 "0"으로 압축한다.
    더이상 압축을 진행할 데이터가 없으므로 닫히는 괄호를 넣는다.
4 <= r <= 7, 0 <= c <= 3
    범위 안에 1 밖에 없으므로 "1"으로 압축한다.
4 <= r <= 7, 4 <= c <= 7
    위의 범위 안에는 0과 1이 혼재하므로 여는 괄호를 넣고 다시 4개의 범위로 나눠서 압축을 진행한다.
        4 <= r <= 5, 4 <= c <= 5
            범위 안에 0 밖에 없으므로 "0"으로 압축한다.
        4 <= r <= 5, 6 <= c <= 7
            범위 안에 0 밖에 없으므로 "0"으로 압축한다.
        6 <= r <= 7, 4 <= c <= 5
            범위 안에 0 밖에 없으므로 "0"으로 압축한다.
        6 <= r <= 7, 6 <= c <= 7
            범위 안에 1 밖에 없으므로 "1"으로 압축한다.
    더이상 압축을 진행할 테이터가 없으므로 닫히는 괄호를 넣는다.
더이상 압축을 진행할 데이터가 없으므로 닫히는 괄호를 넣는다.

위의 과정을 통해 얻은 압축문자열을 정리하면
((110(0101))(0010)1(0001))

시간복잡도
if N = 8 then
    N * N
    N/2 * N/2 * 4
    N/4 * N/4 * 4 * 4
    N/8 * N/8 * 4 * 4 * 4
    total N * N * 4 = 256 회 연산
if N = 16 then
    N * N
    N/2 * N/2 * 4
    N/4 * N/4 * 4 * 4
    N/8 * N/8 * 4 * 4 * 4
    N/16 * N/16 * 4 * 4 * 4 * 4
    total N * N * 5 = 1280 회 연산
따라서 O(N^2 * (log N + 1))이다.
N의 최대값이 64이므로 최대 연산 회수는 28,672회가 된다. 재귀적으로 압축 알고리즘을 작성하면
제한시간 내에 통과 할 수 있다.

공간복잡도
영상 데이터의 최대 크기는 N = 64 일 때 N x N * 4 byte = 16kb 이므로 메모리 제한에
문제 없이 해결 가능하다.
"""
import sys
f_input = sys.stdin.readline


def get_comp_video(v_info, sr, sc, er, ec):
    f_val = v_info[sr][sc]
    is_all_same = True
    d = (er - sr + 1) // 2
    res = ''
    for i in range(sr, er + 1):
        for j in range(sc, ec + 1):
            if v_info[i][j] != f_val:
                is_all_same = False
                break
    if is_all_same:
        res = f_val
    else:
        res = '('
        for pn in range(1, 5):
            if pn == 1:  # 1사분면
                res += get_comp_video(v_info, sr, sc, er - d, ec - d)
            elif pn == 2:  # 2사분면
                res += get_comp_video(v_info, sr, sc + d, er - d, ec)
            elif pn == 3:  # 3사분면
                res += get_comp_video(v_info, sr + d, sc, er, ec - d)
            else:  # 4사분면
                res += get_comp_video(v_info, sr + d, sc + d, er, ec)
        res += ')'
    return res


N = int(f_input().rstrip())
video_info = list()
for _ in range(N):
    video_info.append(f_input().rstrip())

print(get_comp_video(video_info, 0, 0, N - 1, N - 1))
